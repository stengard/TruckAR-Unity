// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace metaio.unitycommunication {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class UnityCommunicationProtos {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    #endregion
    #region Extensions
    internal static readonly object Descriptor;
    static UnityCommunicationProtos() {
      Descriptor = null;
    }
    #endregion
    
  }
  #region Enums
  public enum CameraFacing {
    UNDEFINED = 0,
    BACK = 1,
    FRONT = 2,
  }
  
  public enum CameraFlip {
    NONE = 0,
    VERTICAL = 1,
    HORIZONTAL = 2,
    BOTH = 3,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Vector2d : pb::GeneratedMessageLite<Vector2d, Vector2d.Builder> {
    private Vector2d() { }
    private static readonly Vector2d defaultInstance = new Vector2d().MakeReadOnly();
    private static readonly string[] _vector2DFieldNames = new string[] { "x", "y" };
    private static readonly uint[] _vector2DFieldTags = new uint[] { 13, 21 };
    public static Vector2d DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Vector2d DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Vector2d ThisMessage {
      get { return this; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _vector2DFieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[1], Y);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeFloatSize(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasX) hash ^= x_.GetHashCode();
      if (hasY) hash ^= y_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Vector2d other = obj as Vector2d;
      if (other == null) return false;
      if (hasX != other.hasX || (hasX && !x_.Equals(other.x_))) return false;
      if (hasY != other.hasY || (hasY && !y_.Equals(other.y_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("x", hasX, x_, writer);
      PrintField("y", hasY, y_, writer);
    }
    #endregion
    
    public static Vector2d ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector2d ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector2d ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector2d ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector2d ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector2d ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Vector2d ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Vector2d ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Vector2d ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector2d ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Vector2d MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Vector2d prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Vector2d, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Vector2d cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Vector2d result;
      
      private Vector2d PrepareBuilder() {
        if (resultIsReadOnly) {
          Vector2d original = result;
          result = new Vector2d();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Vector2d MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Vector2d DefaultInstanceForType {
        get { return global::metaio.unitycommunication.Vector2d.DefaultInstance; }
      }
      
      public override Vector2d BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Vector2d) {
          return MergeFrom((Vector2d) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Vector2d other) {
        if (other == global::metaio.unitycommunication.Vector2d.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_vector2DFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _vector2DFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
    }
    static Vector2d() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Vector2di : pb::GeneratedMessageLite<Vector2di, Vector2di.Builder> {
    private Vector2di() { }
    private static readonly Vector2di defaultInstance = new Vector2di().MakeReadOnly();
    private static readonly string[] _vector2DiFieldNames = new string[] { "x", "y" };
    private static readonly uint[] _vector2DiFieldTags = new uint[] { 8, 16 };
    public static Vector2di DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Vector2di DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Vector2di ThisMessage {
      get { return this; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private int x_;
    public bool HasX {
      get { return hasX; }
    }
    public int X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private int y_;
    public bool HasY {
      get { return hasY; }
    }
    public int Y {
      get { return y_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _vector2DiFieldNames;
      if (hasX) {
        output.WriteInt32(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteInt32(2, field_names[1], Y);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Y);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasX) hash ^= x_.GetHashCode();
      if (hasY) hash ^= y_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Vector2di other = obj as Vector2di;
      if (other == null) return false;
      if (hasX != other.hasX || (hasX && !x_.Equals(other.x_))) return false;
      if (hasY != other.hasY || (hasY && !y_.Equals(other.y_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("x", hasX, x_, writer);
      PrintField("y", hasY, y_, writer);
    }
    #endregion
    
    public static Vector2di ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector2di ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector2di ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector2di ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector2di ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector2di ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Vector2di ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Vector2di ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Vector2di ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector2di ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Vector2di MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Vector2di prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Vector2di, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Vector2di cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Vector2di result;
      
      private Vector2di PrepareBuilder() {
        if (resultIsReadOnly) {
          Vector2di original = result;
          result = new Vector2di();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Vector2di MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Vector2di DefaultInstanceForType {
        get { return global::metaio.unitycommunication.Vector2di.DefaultInstance; }
      }
      
      public override Vector2di BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Vector2di) {
          return MergeFrom((Vector2di) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Vector2di other) {
        if (other == global::metaio.unitycommunication.Vector2di.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_vector2DiFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _vector2DiFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasX = input.ReadInt32(ref result.x_);
              break;
            }
            case 16: {
              result.hasY = input.ReadInt32(ref result.y_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public int X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(int value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public int Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(int value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0;
        return this;
      }
    }
    static Vector2di() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Vector3d : pb::GeneratedMessageLite<Vector3d, Vector3d.Builder> {
    private Vector3d() { }
    private static readonly Vector3d defaultInstance = new Vector3d().MakeReadOnly();
    private static readonly string[] _vector3DFieldNames = new string[] { "x", "y", "z" };
    private static readonly uint[] _vector3DFieldTags = new uint[] { 13, 21, 29 };
    public static Vector3d DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Vector3d DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Vector3d ThisMessage {
      get { return this; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public const int ZFieldNumber = 3;
    private bool hasZ;
    private float z_;
    public bool HasZ {
      get { return hasZ; }
    }
    public float Z {
      get { return z_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        if (!hasZ) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _vector3DFieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[1], Y);
      }
      if (hasZ) {
        output.WriteFloat(3, field_names[2], Z);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeFloatSize(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
        }
        if (hasZ) {
          size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasX) hash ^= x_.GetHashCode();
      if (hasY) hash ^= y_.GetHashCode();
      if (hasZ) hash ^= z_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Vector3d other = obj as Vector3d;
      if (other == null) return false;
      if (hasX != other.hasX || (hasX && !x_.Equals(other.x_))) return false;
      if (hasY != other.hasY || (hasY && !y_.Equals(other.y_))) return false;
      if (hasZ != other.hasZ || (hasZ && !z_.Equals(other.z_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("x", hasX, x_, writer);
      PrintField("y", hasY, y_, writer);
      PrintField("z", hasZ, z_, writer);
    }
    #endregion
    
    public static Vector3d ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector3d ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector3d ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector3d ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector3d ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector3d ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Vector3d ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Vector3d ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Vector3d ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector3d ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Vector3d MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Vector3d prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Vector3d, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Vector3d cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Vector3d result;
      
      private Vector3d PrepareBuilder() {
        if (resultIsReadOnly) {
          Vector3d original = result;
          result = new Vector3d();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Vector3d MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Vector3d DefaultInstanceForType {
        get { return global::metaio.unitycommunication.Vector3d.DefaultInstance; }
      }
      
      public override Vector3d BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Vector3d) {
          return MergeFrom((Vector3d) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Vector3d other) {
        if (other == global::metaio.unitycommunication.Vector3d.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasZ) {
          Z = other.Z;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_vector3DFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _vector3DFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
            case 29: {
              result.hasZ = input.ReadFloat(ref result.z_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
      
      public bool HasZ {
        get { return result.hasZ; }
      }
      public float Z {
        get { return result.Z; }
        set { SetZ(value); }
      }
      public Builder SetZ(float value) {
        PrepareBuilder();
        result.hasZ = true;
        result.z_ = value;
        return this;
      }
      public Builder ClearZ() {
        PrepareBuilder();
        result.hasZ = false;
        result.z_ = 0F;
        return this;
      }
    }
    static Vector3d() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Vector4d : pb::GeneratedMessageLite<Vector4d, Vector4d.Builder> {
    private Vector4d() { }
    private static readonly Vector4d defaultInstance = new Vector4d().MakeReadOnly();
    private static readonly string[] _vector4DFieldNames = new string[] { "w", "x", "y", "z" };
    private static readonly uint[] _vector4DFieldTags = new uint[] { 37, 13, 21, 29 };
    public static Vector4d DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Vector4d DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Vector4d ThisMessage {
      get { return this; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public const int ZFieldNumber = 3;
    private bool hasZ;
    private float z_;
    public bool HasZ {
      get { return hasZ; }
    }
    public float Z {
      get { return z_; }
    }
    
    public const int WFieldNumber = 4;
    private bool hasW;
    private float w_;
    public bool HasW {
      get { return hasW; }
    }
    public float W {
      get { return w_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        if (!hasZ) return false;
        if (!hasW) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _vector4DFieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[1], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[2], Y);
      }
      if (hasZ) {
        output.WriteFloat(3, field_names[3], Z);
      }
      if (hasW) {
        output.WriteFloat(4, field_names[0], W);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeFloatSize(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
        }
        if (hasZ) {
          size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
        }
        if (hasW) {
          size += pb::CodedOutputStream.ComputeFloatSize(4, W);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasX) hash ^= x_.GetHashCode();
      if (hasY) hash ^= y_.GetHashCode();
      if (hasZ) hash ^= z_.GetHashCode();
      if (hasW) hash ^= w_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Vector4d other = obj as Vector4d;
      if (other == null) return false;
      if (hasX != other.hasX || (hasX && !x_.Equals(other.x_))) return false;
      if (hasY != other.hasY || (hasY && !y_.Equals(other.y_))) return false;
      if (hasZ != other.hasZ || (hasZ && !z_.Equals(other.z_))) return false;
      if (hasW != other.hasW || (hasW && !w_.Equals(other.w_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("x", hasX, x_, writer);
      PrintField("y", hasY, y_, writer);
      PrintField("z", hasZ, z_, writer);
      PrintField("w", hasW, w_, writer);
    }
    #endregion
    
    public static Vector4d ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector4d ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector4d ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Vector4d ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Vector4d ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector4d ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Vector4d ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Vector4d ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Vector4d ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Vector4d ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Vector4d MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Vector4d prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Vector4d, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Vector4d cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Vector4d result;
      
      private Vector4d PrepareBuilder() {
        if (resultIsReadOnly) {
          Vector4d original = result;
          result = new Vector4d();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Vector4d MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Vector4d DefaultInstanceForType {
        get { return global::metaio.unitycommunication.Vector4d.DefaultInstance; }
      }
      
      public override Vector4d BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Vector4d) {
          return MergeFrom((Vector4d) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Vector4d other) {
        if (other == global::metaio.unitycommunication.Vector4d.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasZ) {
          Z = other.Z;
        }
        if (other.HasW) {
          W = other.W;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_vector4DFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _vector4DFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
            case 29: {
              result.hasZ = input.ReadFloat(ref result.z_);
              break;
            }
            case 37: {
              result.hasW = input.ReadFloat(ref result.w_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
      
      public bool HasZ {
        get { return result.hasZ; }
      }
      public float Z {
        get { return result.Z; }
        set { SetZ(value); }
      }
      public Builder SetZ(float value) {
        PrepareBuilder();
        result.hasZ = true;
        result.z_ = value;
        return this;
      }
      public Builder ClearZ() {
        PrepareBuilder();
        result.hasZ = false;
        result.z_ = 0F;
        return this;
      }
      
      public bool HasW {
        get { return result.hasW; }
      }
      public float W {
        get { return result.W; }
        set { SetW(value); }
      }
      public Builder SetW(float value) {
        PrepareBuilder();
        result.hasW = true;
        result.w_ = value;
        return this;
      }
      public Builder ClearW() {
        PrepareBuilder();
        result.hasW = false;
        result.w_ = 0F;
        return this;
      }
    }
    static Vector4d() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Camera : pb::GeneratedMessageLite<Camera, Camera.Builder> {
    private Camera() { }
    private static readonly Camera defaultInstance = new Camera().MakeReadOnly();
    private static readonly string[] _cameraFieldNames = new string[] { "downsample", "facing", "flip", "fps", "friendlyName", "index", "resolution", "yuvPipeline" };
    private static readonly uint[] _cameraFieldTags = new uint[] { 40, 56, 64, 34, 18, 8, 26, 48 };
    public static Camera DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Camera DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Camera ThisMessage {
      get { return this; }
    }
    
    public const int IndexFieldNumber = 1;
    private bool hasIndex;
    private int index_;
    public bool HasIndex {
      get { return hasIndex; }
    }
    public int Index {
      get { return index_; }
    }
    
    public const int FriendlyNameFieldNumber = 2;
    private bool hasFriendlyName;
    private string friendlyName_ = "";
    public bool HasFriendlyName {
      get { return hasFriendlyName; }
    }
    public string FriendlyName {
      get { return friendlyName_; }
    }
    
    public const int ResolutionFieldNumber = 3;
    private bool hasResolution;
    private global::metaio.unitycommunication.Vector2di resolution_;
    public bool HasResolution {
      get { return hasResolution; }
    }
    public global::metaio.unitycommunication.Vector2di Resolution {
      get { return resolution_ ?? global::metaio.unitycommunication.Vector2di.DefaultInstance; }
    }
    
    public const int FpsFieldNumber = 4;
    private bool hasFps;
    private global::metaio.unitycommunication.Vector2d fps_;
    public bool HasFps {
      get { return hasFps; }
    }
    public global::metaio.unitycommunication.Vector2d Fps {
      get { return fps_ ?? global::metaio.unitycommunication.Vector2d.DefaultInstance; }
    }
    
    public const int DownsampleFieldNumber = 5;
    private bool hasDownsample;
    private uint downsample_;
    public bool HasDownsample {
      get { return hasDownsample; }
    }
    [global::System.CLSCompliant(false)]
    public uint Downsample {
      get { return downsample_; }
    }
    
    public const int YuvPipelineFieldNumber = 6;
    private bool hasYuvPipeline;
    private bool yuvPipeline_;
    public bool HasYuvPipeline {
      get { return hasYuvPipeline; }
    }
    public bool YuvPipeline {
      get { return yuvPipeline_; }
    }
    
    public const int FacingFieldNumber = 7;
    private bool hasFacing;
    private global::metaio.unitycommunication.CameraFacing facing_ = global::metaio.unitycommunication.CameraFacing.UNDEFINED;
    public bool HasFacing {
      get { return hasFacing; }
    }
    public global::metaio.unitycommunication.CameraFacing Facing {
      get { return facing_; }
    }
    
    public const int FlipFieldNumber = 8;
    private bool hasFlip;
    private global::metaio.unitycommunication.CameraFlip flip_ = global::metaio.unitycommunication.CameraFlip.NONE;
    public bool HasFlip {
      get { return hasFlip; }
    }
    public global::metaio.unitycommunication.CameraFlip Flip {
      get { return flip_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasIndex) return false;
        if (!hasFriendlyName) return false;
        if (!hasResolution) return false;
        if (!hasFps) return false;
        if (!hasDownsample) return false;
        if (!hasYuvPipeline) return false;
        if (!hasFacing) return false;
        if (!hasFlip) return false;
        if (!Resolution.IsInitialized) return false;
        if (!Fps.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _cameraFieldNames;
      if (hasIndex) {
        output.WriteInt32(1, field_names[5], Index);
      }
      if (hasFriendlyName) {
        output.WriteString(2, field_names[4], FriendlyName);
      }
      if (hasResolution) {
        output.WriteMessage(3, field_names[6], Resolution);
      }
      if (hasFps) {
        output.WriteMessage(4, field_names[3], Fps);
      }
      if (hasDownsample) {
        output.WriteUInt32(5, field_names[0], Downsample);
      }
      if (hasYuvPipeline) {
        output.WriteBool(6, field_names[7], YuvPipeline);
      }
      if (hasFacing) {
        output.WriteEnum(7, field_names[1], (int) Facing, Facing);
      }
      if (hasFlip) {
        output.WriteEnum(8, field_names[2], (int) Flip, Flip);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasIndex) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Index);
        }
        if (hasFriendlyName) {
          size += pb::CodedOutputStream.ComputeStringSize(2, FriendlyName);
        }
        if (hasResolution) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Resolution);
        }
        if (hasFps) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Fps);
        }
        if (hasDownsample) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, Downsample);
        }
        if (hasYuvPipeline) {
          size += pb::CodedOutputStream.ComputeBoolSize(6, YuvPipeline);
        }
        if (hasFacing) {
          size += pb::CodedOutputStream.ComputeEnumSize(7, (int) Facing);
        }
        if (hasFlip) {
          size += pb::CodedOutputStream.ComputeEnumSize(8, (int) Flip);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasIndex) hash ^= index_.GetHashCode();
      if (hasFriendlyName) hash ^= friendlyName_.GetHashCode();
      if (hasResolution) hash ^= resolution_.GetHashCode();
      if (hasFps) hash ^= fps_.GetHashCode();
      if (hasDownsample) hash ^= downsample_.GetHashCode();
      if (hasYuvPipeline) hash ^= yuvPipeline_.GetHashCode();
      if (hasFacing) hash ^= facing_.GetHashCode();
      if (hasFlip) hash ^= flip_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Camera other = obj as Camera;
      if (other == null) return false;
      if (hasIndex != other.hasIndex || (hasIndex && !index_.Equals(other.index_))) return false;
      if (hasFriendlyName != other.hasFriendlyName || (hasFriendlyName && !friendlyName_.Equals(other.friendlyName_))) return false;
      if (hasResolution != other.hasResolution || (hasResolution && !resolution_.Equals(other.resolution_))) return false;
      if (hasFps != other.hasFps || (hasFps && !fps_.Equals(other.fps_))) return false;
      if (hasDownsample != other.hasDownsample || (hasDownsample && !downsample_.Equals(other.downsample_))) return false;
      if (hasYuvPipeline != other.hasYuvPipeline || (hasYuvPipeline && !yuvPipeline_.Equals(other.yuvPipeline_))) return false;
      if (hasFacing != other.hasFacing || (hasFacing && !facing_.Equals(other.facing_))) return false;
      if (hasFlip != other.hasFlip || (hasFlip && !flip_.Equals(other.flip_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("index", hasIndex, index_, writer);
      PrintField("friendlyName", hasFriendlyName, friendlyName_, writer);
      PrintField("resolution", hasResolution, resolution_, writer);
      PrintField("fps", hasFps, fps_, writer);
      PrintField("downsample", hasDownsample, downsample_, writer);
      PrintField("yuvPipeline", hasYuvPipeline, yuvPipeline_, writer);
      PrintField("facing", hasFacing, facing_, writer);
      PrintField("flip", hasFlip, flip_, writer);
    }
    #endregion
    
    public static Camera ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Camera ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Camera ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Camera ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Camera ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Camera ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Camera ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Camera ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Camera ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Camera ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Camera MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Camera prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Camera, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Camera cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Camera result;
      
      private Camera PrepareBuilder() {
        if (resultIsReadOnly) {
          Camera original = result;
          result = new Camera();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Camera MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Camera DefaultInstanceForType {
        get { return global::metaio.unitycommunication.Camera.DefaultInstance; }
      }
      
      public override Camera BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Camera) {
          return MergeFrom((Camera) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Camera other) {
        if (other == global::metaio.unitycommunication.Camera.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasIndex) {
          Index = other.Index;
        }
        if (other.HasFriendlyName) {
          FriendlyName = other.FriendlyName;
        }
        if (other.HasResolution) {
          MergeResolution(other.Resolution);
        }
        if (other.HasFps) {
          MergeFps(other.Fps);
        }
        if (other.HasDownsample) {
          Downsample = other.Downsample;
        }
        if (other.HasYuvPipeline) {
          YuvPipeline = other.YuvPipeline;
        }
        if (other.HasFacing) {
          Facing = other.Facing;
        }
        if (other.HasFlip) {
          Flip = other.Flip;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_cameraFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _cameraFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasIndex = input.ReadInt32(ref result.index_);
              break;
            }
            case 18: {
              result.hasFriendlyName = input.ReadString(ref result.friendlyName_);
              break;
            }
            case 26: {
              global::metaio.unitycommunication.Vector2di.Builder subBuilder = global::metaio.unitycommunication.Vector2di.CreateBuilder();
              if (result.hasResolution) {
                subBuilder.MergeFrom(Resolution);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Resolution = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::metaio.unitycommunication.Vector2d.Builder subBuilder = global::metaio.unitycommunication.Vector2d.CreateBuilder();
              if (result.hasFps) {
                subBuilder.MergeFrom(Fps);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Fps = subBuilder.BuildPartial();
              break;
            }
            case 40: {
              result.hasDownsample = input.ReadUInt32(ref result.downsample_);
              break;
            }
            case 48: {
              result.hasYuvPipeline = input.ReadBool(ref result.yuvPipeline_);
              break;
            }
            case 56: {
              object unknown;
              if(input.ReadEnum(ref result.facing_, out unknown)) {
                result.hasFacing = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 64: {
              object unknown;
              if(input.ReadEnum(ref result.flip_, out unknown)) {
                result.hasFlip = true;
              } else if(unknown is int) {
              }
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasIndex {
        get { return result.hasIndex; }
      }
      public int Index {
        get { return result.Index; }
        set { SetIndex(value); }
      }
      public Builder SetIndex(int value) {
        PrepareBuilder();
        result.hasIndex = true;
        result.index_ = value;
        return this;
      }
      public Builder ClearIndex() {
        PrepareBuilder();
        result.hasIndex = false;
        result.index_ = 0;
        return this;
      }
      
      public bool HasFriendlyName {
        get { return result.hasFriendlyName; }
      }
      public string FriendlyName {
        get { return result.FriendlyName; }
        set { SetFriendlyName(value); }
      }
      public Builder SetFriendlyName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFriendlyName = true;
        result.friendlyName_ = value;
        return this;
      }
      public Builder ClearFriendlyName() {
        PrepareBuilder();
        result.hasFriendlyName = false;
        result.friendlyName_ = "";
        return this;
      }
      
      public bool HasResolution {
       get { return result.hasResolution; }
      }
      public global::metaio.unitycommunication.Vector2di Resolution {
        get { return result.Resolution; }
        set { SetResolution(value); }
      }
      public Builder SetResolution(global::metaio.unitycommunication.Vector2di value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasResolution = true;
        result.resolution_ = value;
        return this;
      }
      public Builder SetResolution(global::metaio.unitycommunication.Vector2di.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasResolution = true;
        result.resolution_ = builderForValue.Build();
        return this;
      }
      public Builder MergeResolution(global::metaio.unitycommunication.Vector2di value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasResolution &&
            result.resolution_ != global::metaio.unitycommunication.Vector2di.DefaultInstance) {
            result.resolution_ = global::metaio.unitycommunication.Vector2di.CreateBuilder(result.resolution_).MergeFrom(value).BuildPartial();
        } else {
          result.resolution_ = value;
        }
        result.hasResolution = true;
        return this;
      }
      public Builder ClearResolution() {
        PrepareBuilder();
        result.hasResolution = false;
        result.resolution_ = null;
        return this;
      }
      
      public bool HasFps {
       get { return result.hasFps; }
      }
      public global::metaio.unitycommunication.Vector2d Fps {
        get { return result.Fps; }
        set { SetFps(value); }
      }
      public Builder SetFps(global::metaio.unitycommunication.Vector2d value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFps = true;
        result.fps_ = value;
        return this;
      }
      public Builder SetFps(global::metaio.unitycommunication.Vector2d.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasFps = true;
        result.fps_ = builderForValue.Build();
        return this;
      }
      public Builder MergeFps(global::metaio.unitycommunication.Vector2d value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasFps &&
            result.fps_ != global::metaio.unitycommunication.Vector2d.DefaultInstance) {
            result.fps_ = global::metaio.unitycommunication.Vector2d.CreateBuilder(result.fps_).MergeFrom(value).BuildPartial();
        } else {
          result.fps_ = value;
        }
        result.hasFps = true;
        return this;
      }
      public Builder ClearFps() {
        PrepareBuilder();
        result.hasFps = false;
        result.fps_ = null;
        return this;
      }
      
      public bool HasDownsample {
        get { return result.hasDownsample; }
      }
      [global::System.CLSCompliant(false)]
      public uint Downsample {
        get { return result.Downsample; }
        set { SetDownsample(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetDownsample(uint value) {
        PrepareBuilder();
        result.hasDownsample = true;
        result.downsample_ = value;
        return this;
      }
      public Builder ClearDownsample() {
        PrepareBuilder();
        result.hasDownsample = false;
        result.downsample_ = 0;
        return this;
      }
      
      public bool HasYuvPipeline {
        get { return result.hasYuvPipeline; }
      }
      public bool YuvPipeline {
        get { return result.YuvPipeline; }
        set { SetYuvPipeline(value); }
      }
      public Builder SetYuvPipeline(bool value) {
        PrepareBuilder();
        result.hasYuvPipeline = true;
        result.yuvPipeline_ = value;
        return this;
      }
      public Builder ClearYuvPipeline() {
        PrepareBuilder();
        result.hasYuvPipeline = false;
        result.yuvPipeline_ = false;
        return this;
      }
      
      public bool HasFacing {
       get { return result.hasFacing; }
      }
      public global::metaio.unitycommunication.CameraFacing Facing {
        get { return result.Facing; }
        set { SetFacing(value); }
      }
      public Builder SetFacing(global::metaio.unitycommunication.CameraFacing value) {
        PrepareBuilder();
        result.hasFacing = true;
        result.facing_ = value;
        return this;
      }
      public Builder ClearFacing() {
        PrepareBuilder();
        result.hasFacing = false;
        result.facing_ = global::metaio.unitycommunication.CameraFacing.UNDEFINED;
        return this;
      }
      
      public bool HasFlip {
       get { return result.hasFlip; }
      }
      public global::metaio.unitycommunication.CameraFlip Flip {
        get { return result.Flip; }
        set { SetFlip(value); }
      }
      public Builder SetFlip(global::metaio.unitycommunication.CameraFlip value) {
        PrepareBuilder();
        result.hasFlip = true;
        result.flip_ = value;
        return this;
      }
      public Builder ClearFlip() {
        PrepareBuilder();
        result.hasFlip = false;
        result.flip_ = global::metaio.unitycommunication.CameraFlip.NONE;
        return this;
      }
    }
    static Camera() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class LLACoordinate : pb::GeneratedMessageLite<LLACoordinate, LLACoordinate.Builder> {
    private LLACoordinate() { }
    private static readonly LLACoordinate defaultInstance = new LLACoordinate().MakeReadOnly();
    private static readonly string[] _lLACoordinateFieldNames = new string[] { "accuracy", "altitude", "latitude", "longitude", "timestamp" };
    private static readonly uint[] _lLACoordinateFieldTags = new uint[] { 33, 25, 9, 17, 41 };
    public static LLACoordinate DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LLACoordinate DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LLACoordinate ThisMessage {
      get { return this; }
    }
    
    public const int LatitudeFieldNumber = 1;
    private bool hasLatitude;
    private double latitude_;
    public bool HasLatitude {
      get { return hasLatitude; }
    }
    public double Latitude {
      get { return latitude_; }
    }
    
    public const int LongitudeFieldNumber = 2;
    private bool hasLongitude;
    private double longitude_;
    public bool HasLongitude {
      get { return hasLongitude; }
    }
    public double Longitude {
      get { return longitude_; }
    }
    
    public const int AltitudeFieldNumber = 3;
    private bool hasAltitude;
    private double altitude_;
    public bool HasAltitude {
      get { return hasAltitude; }
    }
    public double Altitude {
      get { return altitude_; }
    }
    
    public const int AccuracyFieldNumber = 4;
    private bool hasAccuracy;
    private double accuracy_;
    public bool HasAccuracy {
      get { return hasAccuracy; }
    }
    public double Accuracy {
      get { return accuracy_; }
    }
    
    public const int TimestampFieldNumber = 5;
    private bool hasTimestamp;
    private double timestamp_;
    public bool HasTimestamp {
      get { return hasTimestamp; }
    }
    public double Timestamp {
      get { return timestamp_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasLatitude) return false;
        if (!hasLongitude) return false;
        if (!hasAltitude) return false;
        if (!hasAccuracy) return false;
        if (!hasTimestamp) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _lLACoordinateFieldNames;
      if (hasLatitude) {
        output.WriteDouble(1, field_names[2], Latitude);
      }
      if (hasLongitude) {
        output.WriteDouble(2, field_names[3], Longitude);
      }
      if (hasAltitude) {
        output.WriteDouble(3, field_names[1], Altitude);
      }
      if (hasAccuracy) {
        output.WriteDouble(4, field_names[0], Accuracy);
      }
      if (hasTimestamp) {
        output.WriteDouble(5, field_names[4], Timestamp);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLatitude) {
          size += pb::CodedOutputStream.ComputeDoubleSize(1, Latitude);
        }
        if (hasLongitude) {
          size += pb::CodedOutputStream.ComputeDoubleSize(2, Longitude);
        }
        if (hasAltitude) {
          size += pb::CodedOutputStream.ComputeDoubleSize(3, Altitude);
        }
        if (hasAccuracy) {
          size += pb::CodedOutputStream.ComputeDoubleSize(4, Accuracy);
        }
        if (hasTimestamp) {
          size += pb::CodedOutputStream.ComputeDoubleSize(5, Timestamp);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasLatitude) hash ^= latitude_.GetHashCode();
      if (hasLongitude) hash ^= longitude_.GetHashCode();
      if (hasAltitude) hash ^= altitude_.GetHashCode();
      if (hasAccuracy) hash ^= accuracy_.GetHashCode();
      if (hasTimestamp) hash ^= timestamp_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      LLACoordinate other = obj as LLACoordinate;
      if (other == null) return false;
      if (hasLatitude != other.hasLatitude || (hasLatitude && !latitude_.Equals(other.latitude_))) return false;
      if (hasLongitude != other.hasLongitude || (hasLongitude && !longitude_.Equals(other.longitude_))) return false;
      if (hasAltitude != other.hasAltitude || (hasAltitude && !altitude_.Equals(other.altitude_))) return false;
      if (hasAccuracy != other.hasAccuracy || (hasAccuracy && !accuracy_.Equals(other.accuracy_))) return false;
      if (hasTimestamp != other.hasTimestamp || (hasTimestamp && !timestamp_.Equals(other.timestamp_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("latitude", hasLatitude, latitude_, writer);
      PrintField("longitude", hasLongitude, longitude_, writer);
      PrintField("altitude", hasAltitude, altitude_, writer);
      PrintField("accuracy", hasAccuracy, accuracy_, writer);
      PrintField("timestamp", hasTimestamp, timestamp_, writer);
    }
    #endregion
    
    public static LLACoordinate ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LLACoordinate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LLACoordinate ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LLACoordinate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LLACoordinate ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LLACoordinate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LLACoordinate ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LLACoordinate ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LLACoordinate ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LLACoordinate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LLACoordinate MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LLACoordinate prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<LLACoordinate, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LLACoordinate cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LLACoordinate result;
      
      private LLACoordinate PrepareBuilder() {
        if (resultIsReadOnly) {
          LLACoordinate original = result;
          result = new LLACoordinate();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LLACoordinate MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override LLACoordinate DefaultInstanceForType {
        get { return global::metaio.unitycommunication.LLACoordinate.DefaultInstance; }
      }
      
      public override LLACoordinate BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is LLACoordinate) {
          return MergeFrom((LLACoordinate) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LLACoordinate other) {
        if (other == global::metaio.unitycommunication.LLACoordinate.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLatitude) {
          Latitude = other.Latitude;
        }
        if (other.HasLongitude) {
          Longitude = other.Longitude;
        }
        if (other.HasAltitude) {
          Altitude = other.Altitude;
        }
        if (other.HasAccuracy) {
          Accuracy = other.Accuracy;
        }
        if (other.HasTimestamp) {
          Timestamp = other.Timestamp;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_lLACoordinateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _lLACoordinateFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 9: {
              result.hasLatitude = input.ReadDouble(ref result.latitude_);
              break;
            }
            case 17: {
              result.hasLongitude = input.ReadDouble(ref result.longitude_);
              break;
            }
            case 25: {
              result.hasAltitude = input.ReadDouble(ref result.altitude_);
              break;
            }
            case 33: {
              result.hasAccuracy = input.ReadDouble(ref result.accuracy_);
              break;
            }
            case 41: {
              result.hasTimestamp = input.ReadDouble(ref result.timestamp_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasLatitude {
        get { return result.hasLatitude; }
      }
      public double Latitude {
        get { return result.Latitude; }
        set { SetLatitude(value); }
      }
      public Builder SetLatitude(double value) {
        PrepareBuilder();
        result.hasLatitude = true;
        result.latitude_ = value;
        return this;
      }
      public Builder ClearLatitude() {
        PrepareBuilder();
        result.hasLatitude = false;
        result.latitude_ = 0D;
        return this;
      }
      
      public bool HasLongitude {
        get { return result.hasLongitude; }
      }
      public double Longitude {
        get { return result.Longitude; }
        set { SetLongitude(value); }
      }
      public Builder SetLongitude(double value) {
        PrepareBuilder();
        result.hasLongitude = true;
        result.longitude_ = value;
        return this;
      }
      public Builder ClearLongitude() {
        PrepareBuilder();
        result.hasLongitude = false;
        result.longitude_ = 0D;
        return this;
      }
      
      public bool HasAltitude {
        get { return result.hasAltitude; }
      }
      public double Altitude {
        get { return result.Altitude; }
        set { SetAltitude(value); }
      }
      public Builder SetAltitude(double value) {
        PrepareBuilder();
        result.hasAltitude = true;
        result.altitude_ = value;
        return this;
      }
      public Builder ClearAltitude() {
        PrepareBuilder();
        result.hasAltitude = false;
        result.altitude_ = 0D;
        return this;
      }
      
      public bool HasAccuracy {
        get { return result.hasAccuracy; }
      }
      public double Accuracy {
        get { return result.Accuracy; }
        set { SetAccuracy(value); }
      }
      public Builder SetAccuracy(double value) {
        PrepareBuilder();
        result.hasAccuracy = true;
        result.accuracy_ = value;
        return this;
      }
      public Builder ClearAccuracy() {
        PrepareBuilder();
        result.hasAccuracy = false;
        result.accuracy_ = 0D;
        return this;
      }
      
      public bool HasTimestamp {
        get { return result.hasTimestamp; }
      }
      public double Timestamp {
        get { return result.Timestamp; }
        set { SetTimestamp(value); }
      }
      public Builder SetTimestamp(double value) {
        PrepareBuilder();
        result.hasTimestamp = true;
        result.timestamp_ = value;
        return this;
      }
      public Builder ClearTimestamp() {
        PrepareBuilder();
        result.hasTimestamp = false;
        result.timestamp_ = 0D;
        return this;
      }
    }
    static LLACoordinate() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class TrackingValues : pb::GeneratedMessageLite<TrackingValues, TrackingValues.Builder> {
    private TrackingValues() { }
    private static readonly TrackingValues defaultInstance = new TrackingValues().MakeReadOnly();
    private static readonly string[] _trackingValuesFieldNames = new string[] { "additionalValues", "coordinateSystemID", "cosName", "llaCoordinate", "quality", "rotation", "sensor", "state", "timeElapsed", "timestampInSeconds", "trackingTimeMs", "translation" };
    private static readonly uint[] _trackingValuesFieldTags = new uint[] { 90, 72, 82, 34, 45, 26, 98, 8, 49, 65, 57, 18 };
    public static TrackingValues DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TrackingValues DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TrackingValues ThisMessage {
      get { return this; }
    }
    
    public const int StateFieldNumber = 1;
    private bool hasState;
    private int state_;
    public bool HasState {
      get { return hasState; }
    }
    public int State {
      get { return state_; }
    }
    
    public const int TranslationFieldNumber = 2;
    private bool hasTranslation;
    private global::metaio.unitycommunication.Vector3d translation_;
    public bool HasTranslation {
      get { return hasTranslation; }
    }
    public global::metaio.unitycommunication.Vector3d Translation {
      get { return translation_ ?? global::metaio.unitycommunication.Vector3d.DefaultInstance; }
    }
    
    public const int RotationFieldNumber = 3;
    private bool hasRotation;
    private global::metaio.unitycommunication.Vector4d rotation_;
    public bool HasRotation {
      get { return hasRotation; }
    }
    public global::metaio.unitycommunication.Vector4d Rotation {
      get { return rotation_ ?? global::metaio.unitycommunication.Vector4d.DefaultInstance; }
    }
    
    public const int LlaCoordinateFieldNumber = 4;
    private bool hasLlaCoordinate;
    private global::metaio.unitycommunication.LLACoordinate llaCoordinate_;
    public bool HasLlaCoordinate {
      get { return hasLlaCoordinate; }
    }
    public global::metaio.unitycommunication.LLACoordinate LlaCoordinate {
      get { return llaCoordinate_ ?? global::metaio.unitycommunication.LLACoordinate.DefaultInstance; }
    }
    
    public const int QualityFieldNumber = 5;
    private bool hasQuality;
    private float quality_;
    public bool HasQuality {
      get { return hasQuality; }
    }
    public float Quality {
      get { return quality_; }
    }
    
    public const int TimeElapsedFieldNumber = 6;
    private bool hasTimeElapsed;
    private double timeElapsed_;
    public bool HasTimeElapsed {
      get { return hasTimeElapsed; }
    }
    public double TimeElapsed {
      get { return timeElapsed_; }
    }
    
    public const int TrackingTimeMsFieldNumber = 7;
    private bool hasTrackingTimeMs;
    private double trackingTimeMs_;
    public bool HasTrackingTimeMs {
      get { return hasTrackingTimeMs; }
    }
    public double TrackingTimeMs {
      get { return trackingTimeMs_; }
    }
    
    public const int TimestampInSecondsFieldNumber = 8;
    private bool hasTimestampInSeconds;
    private double timestampInSeconds_;
    public bool HasTimestampInSeconds {
      get { return hasTimestampInSeconds; }
    }
    public double TimestampInSeconds {
      get { return timestampInSeconds_; }
    }
    
    public const int CoordinateSystemIDFieldNumber = 9;
    private bool hasCoordinateSystemID;
    private int coordinateSystemID_;
    public bool HasCoordinateSystemID {
      get { return hasCoordinateSystemID; }
    }
    public int CoordinateSystemID {
      get { return coordinateSystemID_; }
    }
    
    public const int CosNameFieldNumber = 10;
    private bool hasCosName;
    private string cosName_ = "";
    public bool HasCosName {
      get { return hasCosName; }
    }
    public string CosName {
      get { return cosName_; }
    }
    
    public const int AdditionalValuesFieldNumber = 11;
    private bool hasAdditionalValues;
    private string additionalValues_ = "";
    public bool HasAdditionalValues {
      get { return hasAdditionalValues; }
    }
    public string AdditionalValues {
      get { return additionalValues_; }
    }
    
    public const int SensorFieldNumber = 12;
    private bool hasSensor;
    private string sensor_ = "";
    public bool HasSensor {
      get { return hasSensor; }
    }
    public string Sensor {
      get { return sensor_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasState) return false;
        if (!hasTranslation) return false;
        if (!hasRotation) return false;
        if (!hasLlaCoordinate) return false;
        if (!hasQuality) return false;
        if (!hasTimeElapsed) return false;
        if (!hasTrackingTimeMs) return false;
        if (!hasTimestampInSeconds) return false;
        if (!hasCoordinateSystemID) return false;
        if (!hasCosName) return false;
        if (!hasAdditionalValues) return false;
        if (!hasSensor) return false;
        if (!Translation.IsInitialized) return false;
        if (!Rotation.IsInitialized) return false;
        if (!LlaCoordinate.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _trackingValuesFieldNames;
      if (hasState) {
        output.WriteInt32(1, field_names[7], State);
      }
      if (hasTranslation) {
        output.WriteMessage(2, field_names[11], Translation);
      }
      if (hasRotation) {
        output.WriteMessage(3, field_names[5], Rotation);
      }
      if (hasLlaCoordinate) {
        output.WriteMessage(4, field_names[3], LlaCoordinate);
      }
      if (hasQuality) {
        output.WriteFloat(5, field_names[4], Quality);
      }
      if (hasTimeElapsed) {
        output.WriteDouble(6, field_names[8], TimeElapsed);
      }
      if (hasTrackingTimeMs) {
        output.WriteDouble(7, field_names[10], TrackingTimeMs);
      }
      if (hasTimestampInSeconds) {
        output.WriteDouble(8, field_names[9], TimestampInSeconds);
      }
      if (hasCoordinateSystemID) {
        output.WriteInt32(9, field_names[1], CoordinateSystemID);
      }
      if (hasCosName) {
        output.WriteString(10, field_names[2], CosName);
      }
      if (hasAdditionalValues) {
        output.WriteString(11, field_names[0], AdditionalValues);
      }
      if (hasSensor) {
        output.WriteString(12, field_names[6], Sensor);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasState) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, State);
        }
        if (hasTranslation) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Translation);
        }
        if (hasRotation) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, Rotation);
        }
        if (hasLlaCoordinate) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, LlaCoordinate);
        }
        if (hasQuality) {
          size += pb::CodedOutputStream.ComputeFloatSize(5, Quality);
        }
        if (hasTimeElapsed) {
          size += pb::CodedOutputStream.ComputeDoubleSize(6, TimeElapsed);
        }
        if (hasTrackingTimeMs) {
          size += pb::CodedOutputStream.ComputeDoubleSize(7, TrackingTimeMs);
        }
        if (hasTimestampInSeconds) {
          size += pb::CodedOutputStream.ComputeDoubleSize(8, TimestampInSeconds);
        }
        if (hasCoordinateSystemID) {
          size += pb::CodedOutputStream.ComputeInt32Size(9, CoordinateSystemID);
        }
        if (hasCosName) {
          size += pb::CodedOutputStream.ComputeStringSize(10, CosName);
        }
        if (hasAdditionalValues) {
          size += pb::CodedOutputStream.ComputeStringSize(11, AdditionalValues);
        }
        if (hasSensor) {
          size += pb::CodedOutputStream.ComputeStringSize(12, Sensor);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasState) hash ^= state_.GetHashCode();
      if (hasTranslation) hash ^= translation_.GetHashCode();
      if (hasRotation) hash ^= rotation_.GetHashCode();
      if (hasLlaCoordinate) hash ^= llaCoordinate_.GetHashCode();
      if (hasQuality) hash ^= quality_.GetHashCode();
      if (hasTimeElapsed) hash ^= timeElapsed_.GetHashCode();
      if (hasTrackingTimeMs) hash ^= trackingTimeMs_.GetHashCode();
      if (hasTimestampInSeconds) hash ^= timestampInSeconds_.GetHashCode();
      if (hasCoordinateSystemID) hash ^= coordinateSystemID_.GetHashCode();
      if (hasCosName) hash ^= cosName_.GetHashCode();
      if (hasAdditionalValues) hash ^= additionalValues_.GetHashCode();
      if (hasSensor) hash ^= sensor_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      TrackingValues other = obj as TrackingValues;
      if (other == null) return false;
      if (hasState != other.hasState || (hasState && !state_.Equals(other.state_))) return false;
      if (hasTranslation != other.hasTranslation || (hasTranslation && !translation_.Equals(other.translation_))) return false;
      if (hasRotation != other.hasRotation || (hasRotation && !rotation_.Equals(other.rotation_))) return false;
      if (hasLlaCoordinate != other.hasLlaCoordinate || (hasLlaCoordinate && !llaCoordinate_.Equals(other.llaCoordinate_))) return false;
      if (hasQuality != other.hasQuality || (hasQuality && !quality_.Equals(other.quality_))) return false;
      if (hasTimeElapsed != other.hasTimeElapsed || (hasTimeElapsed && !timeElapsed_.Equals(other.timeElapsed_))) return false;
      if (hasTrackingTimeMs != other.hasTrackingTimeMs || (hasTrackingTimeMs && !trackingTimeMs_.Equals(other.trackingTimeMs_))) return false;
      if (hasTimestampInSeconds != other.hasTimestampInSeconds || (hasTimestampInSeconds && !timestampInSeconds_.Equals(other.timestampInSeconds_))) return false;
      if (hasCoordinateSystemID != other.hasCoordinateSystemID || (hasCoordinateSystemID && !coordinateSystemID_.Equals(other.coordinateSystemID_))) return false;
      if (hasCosName != other.hasCosName || (hasCosName && !cosName_.Equals(other.cosName_))) return false;
      if (hasAdditionalValues != other.hasAdditionalValues || (hasAdditionalValues && !additionalValues_.Equals(other.additionalValues_))) return false;
      if (hasSensor != other.hasSensor || (hasSensor && !sensor_.Equals(other.sensor_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("state", hasState, state_, writer);
      PrintField("translation", hasTranslation, translation_, writer);
      PrintField("rotation", hasRotation, rotation_, writer);
      PrintField("llaCoordinate", hasLlaCoordinate, llaCoordinate_, writer);
      PrintField("quality", hasQuality, quality_, writer);
      PrintField("timeElapsed", hasTimeElapsed, timeElapsed_, writer);
      PrintField("trackingTimeMs", hasTrackingTimeMs, trackingTimeMs_, writer);
      PrintField("timestampInSeconds", hasTimestampInSeconds, timestampInSeconds_, writer);
      PrintField("coordinateSystemID", hasCoordinateSystemID, coordinateSystemID_, writer);
      PrintField("cosName", hasCosName, cosName_, writer);
      PrintField("additionalValues", hasAdditionalValues, additionalValues_, writer);
      PrintField("sensor", hasSensor, sensor_, writer);
    }
    #endregion
    
    public static TrackingValues ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TrackingValues ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TrackingValues ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TrackingValues ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TrackingValues ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TrackingValues ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TrackingValues ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TrackingValues ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TrackingValues ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TrackingValues ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TrackingValues MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TrackingValues prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<TrackingValues, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TrackingValues cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TrackingValues result;
      
      private TrackingValues PrepareBuilder() {
        if (resultIsReadOnly) {
          TrackingValues original = result;
          result = new TrackingValues();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TrackingValues MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override TrackingValues DefaultInstanceForType {
        get { return global::metaio.unitycommunication.TrackingValues.DefaultInstance; }
      }
      
      public override TrackingValues BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is TrackingValues) {
          return MergeFrom((TrackingValues) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TrackingValues other) {
        if (other == global::metaio.unitycommunication.TrackingValues.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasState) {
          State = other.State;
        }
        if (other.HasTranslation) {
          MergeTranslation(other.Translation);
        }
        if (other.HasRotation) {
          MergeRotation(other.Rotation);
        }
        if (other.HasLlaCoordinate) {
          MergeLlaCoordinate(other.LlaCoordinate);
        }
        if (other.HasQuality) {
          Quality = other.Quality;
        }
        if (other.HasTimeElapsed) {
          TimeElapsed = other.TimeElapsed;
        }
        if (other.HasTrackingTimeMs) {
          TrackingTimeMs = other.TrackingTimeMs;
        }
        if (other.HasTimestampInSeconds) {
          TimestampInSeconds = other.TimestampInSeconds;
        }
        if (other.HasCoordinateSystemID) {
          CoordinateSystemID = other.CoordinateSystemID;
        }
        if (other.HasCosName) {
          CosName = other.CosName;
        }
        if (other.HasAdditionalValues) {
          AdditionalValues = other.AdditionalValues;
        }
        if (other.HasSensor) {
          Sensor = other.Sensor;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_trackingValuesFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _trackingValuesFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasState = input.ReadInt32(ref result.state_);
              break;
            }
            case 18: {
              global::metaio.unitycommunication.Vector3d.Builder subBuilder = global::metaio.unitycommunication.Vector3d.CreateBuilder();
              if (result.hasTranslation) {
                subBuilder.MergeFrom(Translation);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Translation = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::metaio.unitycommunication.Vector4d.Builder subBuilder = global::metaio.unitycommunication.Vector4d.CreateBuilder();
              if (result.hasRotation) {
                subBuilder.MergeFrom(Rotation);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Rotation = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::metaio.unitycommunication.LLACoordinate.Builder subBuilder = global::metaio.unitycommunication.LLACoordinate.CreateBuilder();
              if (result.hasLlaCoordinate) {
                subBuilder.MergeFrom(LlaCoordinate);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              LlaCoordinate = subBuilder.BuildPartial();
              break;
            }
            case 45: {
              result.hasQuality = input.ReadFloat(ref result.quality_);
              break;
            }
            case 49: {
              result.hasTimeElapsed = input.ReadDouble(ref result.timeElapsed_);
              break;
            }
            case 57: {
              result.hasTrackingTimeMs = input.ReadDouble(ref result.trackingTimeMs_);
              break;
            }
            case 65: {
              result.hasTimestampInSeconds = input.ReadDouble(ref result.timestampInSeconds_);
              break;
            }
            case 72: {
              result.hasCoordinateSystemID = input.ReadInt32(ref result.coordinateSystemID_);
              break;
            }
            case 82: {
              result.hasCosName = input.ReadString(ref result.cosName_);
              break;
            }
            case 90: {
              result.hasAdditionalValues = input.ReadString(ref result.additionalValues_);
              break;
            }
            case 98: {
              result.hasSensor = input.ReadString(ref result.sensor_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasState {
        get { return result.hasState; }
      }
      public int State {
        get { return result.State; }
        set { SetState(value); }
      }
      public Builder SetState(int value) {
        PrepareBuilder();
        result.hasState = true;
        result.state_ = value;
        return this;
      }
      public Builder ClearState() {
        PrepareBuilder();
        result.hasState = false;
        result.state_ = 0;
        return this;
      }
      
      public bool HasTranslation {
       get { return result.hasTranslation; }
      }
      public global::metaio.unitycommunication.Vector3d Translation {
        get { return result.Translation; }
        set { SetTranslation(value); }
      }
      public Builder SetTranslation(global::metaio.unitycommunication.Vector3d value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTranslation = true;
        result.translation_ = value;
        return this;
      }
      public Builder SetTranslation(global::metaio.unitycommunication.Vector3d.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasTranslation = true;
        result.translation_ = builderForValue.Build();
        return this;
      }
      public Builder MergeTranslation(global::metaio.unitycommunication.Vector3d value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasTranslation &&
            result.translation_ != global::metaio.unitycommunication.Vector3d.DefaultInstance) {
            result.translation_ = global::metaio.unitycommunication.Vector3d.CreateBuilder(result.translation_).MergeFrom(value).BuildPartial();
        } else {
          result.translation_ = value;
        }
        result.hasTranslation = true;
        return this;
      }
      public Builder ClearTranslation() {
        PrepareBuilder();
        result.hasTranslation = false;
        result.translation_ = null;
        return this;
      }
      
      public bool HasRotation {
       get { return result.hasRotation; }
      }
      public global::metaio.unitycommunication.Vector4d Rotation {
        get { return result.Rotation; }
        set { SetRotation(value); }
      }
      public Builder SetRotation(global::metaio.unitycommunication.Vector4d value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRotation = true;
        result.rotation_ = value;
        return this;
      }
      public Builder SetRotation(global::metaio.unitycommunication.Vector4d.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRotation = true;
        result.rotation_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRotation(global::metaio.unitycommunication.Vector4d value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRotation &&
            result.rotation_ != global::metaio.unitycommunication.Vector4d.DefaultInstance) {
            result.rotation_ = global::metaio.unitycommunication.Vector4d.CreateBuilder(result.rotation_).MergeFrom(value).BuildPartial();
        } else {
          result.rotation_ = value;
        }
        result.hasRotation = true;
        return this;
      }
      public Builder ClearRotation() {
        PrepareBuilder();
        result.hasRotation = false;
        result.rotation_ = null;
        return this;
      }
      
      public bool HasLlaCoordinate {
       get { return result.hasLlaCoordinate; }
      }
      public global::metaio.unitycommunication.LLACoordinate LlaCoordinate {
        get { return result.LlaCoordinate; }
        set { SetLlaCoordinate(value); }
      }
      public Builder SetLlaCoordinate(global::metaio.unitycommunication.LLACoordinate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLlaCoordinate = true;
        result.llaCoordinate_ = value;
        return this;
      }
      public Builder SetLlaCoordinate(global::metaio.unitycommunication.LLACoordinate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLlaCoordinate = true;
        result.llaCoordinate_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLlaCoordinate(global::metaio.unitycommunication.LLACoordinate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLlaCoordinate &&
            result.llaCoordinate_ != global::metaio.unitycommunication.LLACoordinate.DefaultInstance) {
            result.llaCoordinate_ = global::metaio.unitycommunication.LLACoordinate.CreateBuilder(result.llaCoordinate_).MergeFrom(value).BuildPartial();
        } else {
          result.llaCoordinate_ = value;
        }
        result.hasLlaCoordinate = true;
        return this;
      }
      public Builder ClearLlaCoordinate() {
        PrepareBuilder();
        result.hasLlaCoordinate = false;
        result.llaCoordinate_ = null;
        return this;
      }
      
      public bool HasQuality {
        get { return result.hasQuality; }
      }
      public float Quality {
        get { return result.Quality; }
        set { SetQuality(value); }
      }
      public Builder SetQuality(float value) {
        PrepareBuilder();
        result.hasQuality = true;
        result.quality_ = value;
        return this;
      }
      public Builder ClearQuality() {
        PrepareBuilder();
        result.hasQuality = false;
        result.quality_ = 0F;
        return this;
      }
      
      public bool HasTimeElapsed {
        get { return result.hasTimeElapsed; }
      }
      public double TimeElapsed {
        get { return result.TimeElapsed; }
        set { SetTimeElapsed(value); }
      }
      public Builder SetTimeElapsed(double value) {
        PrepareBuilder();
        result.hasTimeElapsed = true;
        result.timeElapsed_ = value;
        return this;
      }
      public Builder ClearTimeElapsed() {
        PrepareBuilder();
        result.hasTimeElapsed = false;
        result.timeElapsed_ = 0D;
        return this;
      }
      
      public bool HasTrackingTimeMs {
        get { return result.hasTrackingTimeMs; }
      }
      public double TrackingTimeMs {
        get { return result.TrackingTimeMs; }
        set { SetTrackingTimeMs(value); }
      }
      public Builder SetTrackingTimeMs(double value) {
        PrepareBuilder();
        result.hasTrackingTimeMs = true;
        result.trackingTimeMs_ = value;
        return this;
      }
      public Builder ClearTrackingTimeMs() {
        PrepareBuilder();
        result.hasTrackingTimeMs = false;
        result.trackingTimeMs_ = 0D;
        return this;
      }
      
      public bool HasTimestampInSeconds {
        get { return result.hasTimestampInSeconds; }
      }
      public double TimestampInSeconds {
        get { return result.TimestampInSeconds; }
        set { SetTimestampInSeconds(value); }
      }
      public Builder SetTimestampInSeconds(double value) {
        PrepareBuilder();
        result.hasTimestampInSeconds = true;
        result.timestampInSeconds_ = value;
        return this;
      }
      public Builder ClearTimestampInSeconds() {
        PrepareBuilder();
        result.hasTimestampInSeconds = false;
        result.timestampInSeconds_ = 0D;
        return this;
      }
      
      public bool HasCoordinateSystemID {
        get { return result.hasCoordinateSystemID; }
      }
      public int CoordinateSystemID {
        get { return result.CoordinateSystemID; }
        set { SetCoordinateSystemID(value); }
      }
      public Builder SetCoordinateSystemID(int value) {
        PrepareBuilder();
        result.hasCoordinateSystemID = true;
        result.coordinateSystemID_ = value;
        return this;
      }
      public Builder ClearCoordinateSystemID() {
        PrepareBuilder();
        result.hasCoordinateSystemID = false;
        result.coordinateSystemID_ = 0;
        return this;
      }
      
      public bool HasCosName {
        get { return result.hasCosName; }
      }
      public string CosName {
        get { return result.CosName; }
        set { SetCosName(value); }
      }
      public Builder SetCosName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCosName = true;
        result.cosName_ = value;
        return this;
      }
      public Builder ClearCosName() {
        PrepareBuilder();
        result.hasCosName = false;
        result.cosName_ = "";
        return this;
      }
      
      public bool HasAdditionalValues {
        get { return result.hasAdditionalValues; }
      }
      public string AdditionalValues {
        get { return result.AdditionalValues; }
        set { SetAdditionalValues(value); }
      }
      public Builder SetAdditionalValues(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAdditionalValues = true;
        result.additionalValues_ = value;
        return this;
      }
      public Builder ClearAdditionalValues() {
        PrepareBuilder();
        result.hasAdditionalValues = false;
        result.additionalValues_ = "";
        return this;
      }
      
      public bool HasSensor {
        get { return result.hasSensor; }
      }
      public string Sensor {
        get { return result.Sensor; }
        set { SetSensor(value); }
      }
      public Builder SetSensor(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSensor = true;
        result.sensor_ = value;
        return this;
      }
      public Builder ClearSensor() {
        PrepareBuilder();
        result.hasSensor = false;
        result.sensor_ = "";
        return this;
      }
    }
    static TrackingValues() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class OnTrackingEventProtocol : pb::GeneratedMessageLite<OnTrackingEventProtocol, OnTrackingEventProtocol.Builder> {
    private OnTrackingEventProtocol() { }
    private static readonly OnTrackingEventProtocol defaultInstance = new OnTrackingEventProtocol().MakeReadOnly();
    private static readonly string[] _onTrackingEventProtocolFieldNames = new string[] { "trackingValues" };
    private static readonly uint[] _onTrackingEventProtocolFieldTags = new uint[] { 10 };
    public static OnTrackingEventProtocol DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OnTrackingEventProtocol DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OnTrackingEventProtocol ThisMessage {
      get { return this; }
    }
    
    public const int TrackingValuesFieldNumber = 1;
    private pbc::PopsicleList<global::metaio.unitycommunication.TrackingValues> trackingValues_ = new pbc::PopsicleList<global::metaio.unitycommunication.TrackingValues>();
    public scg::IList<global::metaio.unitycommunication.TrackingValues> TrackingValuesList {
      get { return trackingValues_; }
    }
    public int TrackingValuesCount {
      get { return trackingValues_.Count; }
    }
    public global::metaio.unitycommunication.TrackingValues GetTrackingValues(int index) {
      return trackingValues_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::metaio.unitycommunication.TrackingValues element in TrackingValuesList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _onTrackingEventProtocolFieldNames;
      if (trackingValues_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], trackingValues_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::metaio.unitycommunication.TrackingValues element in TrackingValuesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      foreach(global::metaio.unitycommunication.TrackingValues i in trackingValues_)
        hash ^= i.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      OnTrackingEventProtocol other = obj as OnTrackingEventProtocol;
      if (other == null) return false;
      if(trackingValues_.Count != other.trackingValues_.Count) return false;
      for(int ix=0; ix < trackingValues_.Count; ix++)
        if(!trackingValues_[ix].Equals(other.trackingValues_[ix])) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("trackingValues", trackingValues_, writer);
    }
    #endregion
    
    public static OnTrackingEventProtocol ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OnTrackingEventProtocol ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OnTrackingEventProtocol MakeReadOnly() {
      trackingValues_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OnTrackingEventProtocol prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<OnTrackingEventProtocol, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OnTrackingEventProtocol cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OnTrackingEventProtocol result;
      
      private OnTrackingEventProtocol PrepareBuilder() {
        if (resultIsReadOnly) {
          OnTrackingEventProtocol original = result;
          result = new OnTrackingEventProtocol();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OnTrackingEventProtocol MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override OnTrackingEventProtocol DefaultInstanceForType {
        get { return global::metaio.unitycommunication.OnTrackingEventProtocol.DefaultInstance; }
      }
      
      public override OnTrackingEventProtocol BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is OnTrackingEventProtocol) {
          return MergeFrom((OnTrackingEventProtocol) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OnTrackingEventProtocol other) {
        if (other == global::metaio.unitycommunication.OnTrackingEventProtocol.DefaultInstance) return this;
        PrepareBuilder();
        if (other.trackingValues_.Count != 0) {
          result.trackingValues_.Add(other.trackingValues_);
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_onTrackingEventProtocolFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _onTrackingEventProtocolFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.trackingValues_, global::metaio.unitycommunication.TrackingValues.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public pbc::IPopsicleList<global::metaio.unitycommunication.TrackingValues> TrackingValuesList {
        get { return PrepareBuilder().trackingValues_; }
      }
      public int TrackingValuesCount {
        get { return result.TrackingValuesCount; }
      }
      public global::metaio.unitycommunication.TrackingValues GetTrackingValues(int index) {
        return result.GetTrackingValues(index);
      }
      public Builder SetTrackingValues(int index, global::metaio.unitycommunication.TrackingValues value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.trackingValues_[index] = value;
        return this;
      }
      public Builder SetTrackingValues(int index, global::metaio.unitycommunication.TrackingValues.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.trackingValues_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddTrackingValues(global::metaio.unitycommunication.TrackingValues value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.trackingValues_.Add(value);
        return this;
      }
      public Builder AddTrackingValues(global::metaio.unitycommunication.TrackingValues.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.trackingValues_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeTrackingValues(scg::IEnumerable<global::metaio.unitycommunication.TrackingValues> values) {
        PrepareBuilder();
        result.trackingValues_.Add(values);
        return this;
      }
      public Builder ClearTrackingValues() {
        PrepareBuilder();
        result.trackingValues_.Clear();
        return this;
      }
    }
    static OnTrackingEventProtocol() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ListCamerasProtocol : pb::GeneratedMessageLite<ListCamerasProtocol, ListCamerasProtocol.Builder> {
    private ListCamerasProtocol() { }
    private static readonly ListCamerasProtocol defaultInstance = new ListCamerasProtocol().MakeReadOnly();
    private static readonly string[] _listCamerasProtocolFieldNames = new string[] { "cameras" };
    private static readonly uint[] _listCamerasProtocolFieldTags = new uint[] { 10 };
    public static ListCamerasProtocol DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ListCamerasProtocol DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ListCamerasProtocol ThisMessage {
      get { return this; }
    }
    
    public const int CamerasFieldNumber = 1;
    private pbc::PopsicleList<global::metaio.unitycommunication.Camera> cameras_ = new pbc::PopsicleList<global::metaio.unitycommunication.Camera>();
    public scg::IList<global::metaio.unitycommunication.Camera> CamerasList {
      get { return cameras_; }
    }
    public int CamerasCount {
      get { return cameras_.Count; }
    }
    public global::metaio.unitycommunication.Camera GetCameras(int index) {
      return cameras_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::metaio.unitycommunication.Camera element in CamerasList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _listCamerasProtocolFieldNames;
      if (cameras_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], cameras_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::metaio.unitycommunication.Camera element in CamerasList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      foreach(global::metaio.unitycommunication.Camera i in cameras_)
        hash ^= i.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      ListCamerasProtocol other = obj as ListCamerasProtocol;
      if (other == null) return false;
      if(cameras_.Count != other.cameras_.Count) return false;
      for(int ix=0; ix < cameras_.Count; ix++)
        if(!cameras_[ix].Equals(other.cameras_[ix])) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("cameras", cameras_, writer);
    }
    #endregion
    
    public static ListCamerasProtocol ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ListCamerasProtocol ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ListCamerasProtocol ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ListCamerasProtocol ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ListCamerasProtocol MakeReadOnly() {
      cameras_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ListCamerasProtocol prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<ListCamerasProtocol, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ListCamerasProtocol cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ListCamerasProtocol result;
      
      private ListCamerasProtocol PrepareBuilder() {
        if (resultIsReadOnly) {
          ListCamerasProtocol original = result;
          result = new ListCamerasProtocol();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ListCamerasProtocol MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override ListCamerasProtocol DefaultInstanceForType {
        get { return global::metaio.unitycommunication.ListCamerasProtocol.DefaultInstance; }
      }
      
      public override ListCamerasProtocol BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is ListCamerasProtocol) {
          return MergeFrom((ListCamerasProtocol) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ListCamerasProtocol other) {
        if (other == global::metaio.unitycommunication.ListCamerasProtocol.DefaultInstance) return this;
        PrepareBuilder();
        if (other.cameras_.Count != 0) {
          result.cameras_.Add(other.cameras_);
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_listCamerasProtocolFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _listCamerasProtocolFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.cameras_, global::metaio.unitycommunication.Camera.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public pbc::IPopsicleList<global::metaio.unitycommunication.Camera> CamerasList {
        get { return PrepareBuilder().cameras_; }
      }
      public int CamerasCount {
        get { return result.CamerasCount; }
      }
      public global::metaio.unitycommunication.Camera GetCameras(int index) {
        return result.GetCameras(index);
      }
      public Builder SetCameras(int index, global::metaio.unitycommunication.Camera value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.cameras_[index] = value;
        return this;
      }
      public Builder SetCameras(int index, global::metaio.unitycommunication.Camera.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.cameras_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCameras(global::metaio.unitycommunication.Camera value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.cameras_.Add(value);
        return this;
      }
      public Builder AddCameras(global::metaio.unitycommunication.Camera.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.cameras_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCameras(scg::IEnumerable<global::metaio.unitycommunication.Camera> values) {
        PrepareBuilder();
        result.cameras_.Add(values);
        return this;
      }
      public Builder ClearCameras() {
        PrepareBuilder();
        result.cameras_.Clear();
        return this;
      }
    }
    static ListCamerasProtocol() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class StartCameraProtocol : pb::GeneratedMessageLite<StartCameraProtocol, StartCameraProtocol.Builder> {
    private StartCameraProtocol() { }
    private static readonly StartCameraProtocol defaultInstance = new StartCameraProtocol().MakeReadOnly();
    private static readonly string[] _startCameraProtocolFieldNames = new string[] { "camera" };
    private static readonly uint[] _startCameraProtocolFieldTags = new uint[] { 10 };
    public static StartCameraProtocol DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override StartCameraProtocol DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override StartCameraProtocol ThisMessage {
      get { return this; }
    }
    
    public const int CameraFieldNumber = 1;
    private bool hasCamera;
    private global::metaio.unitycommunication.Camera camera_;
    public bool HasCamera {
      get { return hasCamera; }
    }
    public global::metaio.unitycommunication.Camera Camera {
      get { return camera_ ?? global::metaio.unitycommunication.Camera.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCamera) return false;
        if (!Camera.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _startCameraProtocolFieldNames;
      if (hasCamera) {
        output.WriteMessage(1, field_names[0], Camera);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCamera) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Camera);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasCamera) hash ^= camera_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      StartCameraProtocol other = obj as StartCameraProtocol;
      if (other == null) return false;
      if (hasCamera != other.hasCamera || (hasCamera && !camera_.Equals(other.camera_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("camera", hasCamera, camera_, writer);
    }
    #endregion
    
    public static StartCameraProtocol ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static StartCameraProtocol ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static StartCameraProtocol ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StartCameraProtocol ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private StartCameraProtocol MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(StartCameraProtocol prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<StartCameraProtocol, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(StartCameraProtocol cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private StartCameraProtocol result;
      
      private StartCameraProtocol PrepareBuilder() {
        if (resultIsReadOnly) {
          StartCameraProtocol original = result;
          result = new StartCameraProtocol();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override StartCameraProtocol MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override StartCameraProtocol DefaultInstanceForType {
        get { return global::metaio.unitycommunication.StartCameraProtocol.DefaultInstance; }
      }
      
      public override StartCameraProtocol BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is StartCameraProtocol) {
          return MergeFrom((StartCameraProtocol) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(StartCameraProtocol other) {
        if (other == global::metaio.unitycommunication.StartCameraProtocol.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCamera) {
          MergeCamera(other.Camera);
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_startCameraProtocolFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _startCameraProtocolFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::metaio.unitycommunication.Camera.Builder subBuilder = global::metaio.unitycommunication.Camera.CreateBuilder();
              if (result.hasCamera) {
                subBuilder.MergeFrom(Camera);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Camera = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasCamera {
       get { return result.hasCamera; }
      }
      public global::metaio.unitycommunication.Camera Camera {
        get { return result.Camera; }
        set { SetCamera(value); }
      }
      public Builder SetCamera(global::metaio.unitycommunication.Camera value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCamera = true;
        result.camera_ = value;
        return this;
      }
      public Builder SetCamera(global::metaio.unitycommunication.Camera.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCamera = true;
        result.camera_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCamera(global::metaio.unitycommunication.Camera value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCamera &&
            result.camera_ != global::metaio.unitycommunication.Camera.DefaultInstance) {
            result.camera_ = global::metaio.unitycommunication.Camera.CreateBuilder(result.camera_).MergeFrom(value).BuildPartial();
        } else {
          result.camera_ = value;
        }
        result.hasCamera = true;
        return this;
      }
      public Builder ClearCamera() {
        PrepareBuilder();
        result.hasCamera = false;
        result.camera_ = null;
        return this;
      }
    }
    static StartCameraProtocol() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class VisualSearchResponse : pb::GeneratedMessageLite<VisualSearchResponse, VisualSearchResponse.Builder> {
    private VisualSearchResponse() { }
    private static readonly VisualSearchResponse defaultInstance = new VisualSearchResponse().MakeReadOnly();
    private static readonly string[] _visualSearchResponseFieldNames = new string[] { "metadata", "trackingConfiguration", "trackingConfigurationName", "visualSearchScore" };
    private static readonly uint[] _visualSearchResponseFieldTags = new uint[] { 34, 18, 10, 29 };
    public static VisualSearchResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override VisualSearchResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override VisualSearchResponse ThisMessage {
      get { return this; }
    }
    
    public const int TrackingConfigurationNameFieldNumber = 1;
    private bool hasTrackingConfigurationName;
    private string trackingConfigurationName_ = "";
    public bool HasTrackingConfigurationName {
      get { return hasTrackingConfigurationName; }
    }
    public string TrackingConfigurationName {
      get { return trackingConfigurationName_; }
    }
    
    public const int TrackingConfigurationFieldNumber = 2;
    private bool hasTrackingConfiguration;
    private string trackingConfiguration_ = "";
    public bool HasTrackingConfiguration {
      get { return hasTrackingConfiguration; }
    }
    public string TrackingConfiguration {
      get { return trackingConfiguration_; }
    }
    
    public const int VisualSearchScoreFieldNumber = 3;
    private bool hasVisualSearchScore;
    private float visualSearchScore_;
    public bool HasVisualSearchScore {
      get { return hasVisualSearchScore; }
    }
    public float VisualSearchScore {
      get { return visualSearchScore_; }
    }
    
    public const int MetadataFieldNumber = 4;
    private bool hasMetadata;
    private string metadata_ = "";
    public bool HasMetadata {
      get { return hasMetadata; }
    }
    public string Metadata {
      get { return metadata_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasTrackingConfigurationName) return false;
        if (!hasTrackingConfiguration) return false;
        if (!hasVisualSearchScore) return false;
        if (!hasMetadata) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _visualSearchResponseFieldNames;
      if (hasTrackingConfigurationName) {
        output.WriteString(1, field_names[2], TrackingConfigurationName);
      }
      if (hasTrackingConfiguration) {
        output.WriteString(2, field_names[1], TrackingConfiguration);
      }
      if (hasVisualSearchScore) {
        output.WriteFloat(3, field_names[3], VisualSearchScore);
      }
      if (hasMetadata) {
        output.WriteString(4, field_names[0], Metadata);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTrackingConfigurationName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, TrackingConfigurationName);
        }
        if (hasTrackingConfiguration) {
          size += pb::CodedOutputStream.ComputeStringSize(2, TrackingConfiguration);
        }
        if (hasVisualSearchScore) {
          size += pb::CodedOutputStream.ComputeFloatSize(3, VisualSearchScore);
        }
        if (hasMetadata) {
          size += pb::CodedOutputStream.ComputeStringSize(4, Metadata);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasTrackingConfigurationName) hash ^= trackingConfigurationName_.GetHashCode();
      if (hasTrackingConfiguration) hash ^= trackingConfiguration_.GetHashCode();
      if (hasVisualSearchScore) hash ^= visualSearchScore_.GetHashCode();
      if (hasMetadata) hash ^= metadata_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      VisualSearchResponse other = obj as VisualSearchResponse;
      if (other == null) return false;
      if (hasTrackingConfigurationName != other.hasTrackingConfigurationName || (hasTrackingConfigurationName && !trackingConfigurationName_.Equals(other.trackingConfigurationName_))) return false;
      if (hasTrackingConfiguration != other.hasTrackingConfiguration || (hasTrackingConfiguration && !trackingConfiguration_.Equals(other.trackingConfiguration_))) return false;
      if (hasVisualSearchScore != other.hasVisualSearchScore || (hasVisualSearchScore && !visualSearchScore_.Equals(other.visualSearchScore_))) return false;
      if (hasMetadata != other.hasMetadata || (hasMetadata && !metadata_.Equals(other.metadata_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("trackingConfigurationName", hasTrackingConfigurationName, trackingConfigurationName_, writer);
      PrintField("trackingConfiguration", hasTrackingConfiguration, trackingConfiguration_, writer);
      PrintField("visualSearchScore", hasVisualSearchScore, visualSearchScore_, writer);
      PrintField("metadata", hasMetadata, metadata_, writer);
    }
    #endregion
    
    public static VisualSearchResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static VisualSearchResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static VisualSearchResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static VisualSearchResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private VisualSearchResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(VisualSearchResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<VisualSearchResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(VisualSearchResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private VisualSearchResponse result;
      
      private VisualSearchResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          VisualSearchResponse original = result;
          result = new VisualSearchResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override VisualSearchResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override VisualSearchResponse DefaultInstanceForType {
        get { return global::metaio.unitycommunication.VisualSearchResponse.DefaultInstance; }
      }
      
      public override VisualSearchResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is VisualSearchResponse) {
          return MergeFrom((VisualSearchResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(VisualSearchResponse other) {
        if (other == global::metaio.unitycommunication.VisualSearchResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTrackingConfigurationName) {
          TrackingConfigurationName = other.TrackingConfigurationName;
        }
        if (other.HasTrackingConfiguration) {
          TrackingConfiguration = other.TrackingConfiguration;
        }
        if (other.HasVisualSearchScore) {
          VisualSearchScore = other.VisualSearchScore;
        }
        if (other.HasMetadata) {
          Metadata = other.Metadata;
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_visualSearchResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _visualSearchResponseFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasTrackingConfigurationName = input.ReadString(ref result.trackingConfigurationName_);
              break;
            }
            case 18: {
              result.hasTrackingConfiguration = input.ReadString(ref result.trackingConfiguration_);
              break;
            }
            case 29: {
              result.hasVisualSearchScore = input.ReadFloat(ref result.visualSearchScore_);
              break;
            }
            case 34: {
              result.hasMetadata = input.ReadString(ref result.metadata_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasTrackingConfigurationName {
        get { return result.hasTrackingConfigurationName; }
      }
      public string TrackingConfigurationName {
        get { return result.TrackingConfigurationName; }
        set { SetTrackingConfigurationName(value); }
      }
      public Builder SetTrackingConfigurationName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTrackingConfigurationName = true;
        result.trackingConfigurationName_ = value;
        return this;
      }
      public Builder ClearTrackingConfigurationName() {
        PrepareBuilder();
        result.hasTrackingConfigurationName = false;
        result.trackingConfigurationName_ = "";
        return this;
      }
      
      public bool HasTrackingConfiguration {
        get { return result.hasTrackingConfiguration; }
      }
      public string TrackingConfiguration {
        get { return result.TrackingConfiguration; }
        set { SetTrackingConfiguration(value); }
      }
      public Builder SetTrackingConfiguration(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTrackingConfiguration = true;
        result.trackingConfiguration_ = value;
        return this;
      }
      public Builder ClearTrackingConfiguration() {
        PrepareBuilder();
        result.hasTrackingConfiguration = false;
        result.trackingConfiguration_ = "";
        return this;
      }
      
      public bool HasVisualSearchScore {
        get { return result.hasVisualSearchScore; }
      }
      public float VisualSearchScore {
        get { return result.VisualSearchScore; }
        set { SetVisualSearchScore(value); }
      }
      public Builder SetVisualSearchScore(float value) {
        PrepareBuilder();
        result.hasVisualSearchScore = true;
        result.visualSearchScore_ = value;
        return this;
      }
      public Builder ClearVisualSearchScore() {
        PrepareBuilder();
        result.hasVisualSearchScore = false;
        result.visualSearchScore_ = 0F;
        return this;
      }
      
      public bool HasMetadata {
        get { return result.hasMetadata; }
      }
      public string Metadata {
        get { return result.Metadata; }
        set { SetMetadata(value); }
      }
      public Builder SetMetadata(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMetadata = true;
        result.metadata_ = value;
        return this;
      }
      public Builder ClearMetadata() {
        PrepareBuilder();
        result.hasMetadata = false;
        result.metadata_ = "";
        return this;
      }
    }
    static VisualSearchResponse() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class OnVisualSearchResultProtocol : pb::GeneratedMessageLite<OnVisualSearchResultProtocol, OnVisualSearchResultProtocol.Builder> {
    private OnVisualSearchResultProtocol() { }
    private static readonly OnVisualSearchResultProtocol defaultInstance = new OnVisualSearchResultProtocol().MakeReadOnly();
    private static readonly string[] _onVisualSearchResultProtocolFieldNames = new string[] { "errorCode", "responses" };
    private static readonly uint[] _onVisualSearchResultProtocolFieldTags = new uint[] { 8, 18 };
    public static OnVisualSearchResultProtocol DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OnVisualSearchResultProtocol DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OnVisualSearchResultProtocol ThisMessage {
      get { return this; }
    }
    
    public const int ErrorCodeFieldNumber = 1;
    private bool hasErrorCode;
    private int errorCode_;
    public bool HasErrorCode {
      get { return hasErrorCode; }
    }
    public int ErrorCode {
      get { return errorCode_; }
    }
    
    public const int ResponsesFieldNumber = 2;
    private pbc::PopsicleList<global::metaio.unitycommunication.VisualSearchResponse> responses_ = new pbc::PopsicleList<global::metaio.unitycommunication.VisualSearchResponse>();
    public scg::IList<global::metaio.unitycommunication.VisualSearchResponse> ResponsesList {
      get { return responses_; }
    }
    public int ResponsesCount {
      get { return responses_.Count; }
    }
    public global::metaio.unitycommunication.VisualSearchResponse GetResponses(int index) {
      return responses_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasErrorCode) return false;
        foreach (global::metaio.unitycommunication.VisualSearchResponse element in ResponsesList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      #pragma warning disable 0219
      int size = SerializedSize;
      #pragma warning restore 0219
      string[] field_names = _onVisualSearchResultProtocolFieldNames;
      if (hasErrorCode) {
        output.WriteInt32(1, field_names[0], ErrorCode);
      }
      if (responses_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], responses_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasErrorCode) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, ErrorCode);
        }
        foreach (global::metaio.unitycommunication.VisualSearchResponse element in ResponsesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasErrorCode) hash ^= errorCode_.GetHashCode();
      foreach(global::metaio.unitycommunication.VisualSearchResponse i in responses_)
        hash ^= i.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      OnVisualSearchResultProtocol other = obj as OnVisualSearchResultProtocol;
      if (other == null) return false;
      if (hasErrorCode != other.hasErrorCode || (hasErrorCode && !errorCode_.Equals(other.errorCode_))) return false;
      if(responses_.Count != other.responses_.Count) return false;
      for(int ix=0; ix < responses_.Count; ix++)
        if(!responses_[ix].Equals(other.responses_[ix])) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("errorCode", hasErrorCode, errorCode_, writer);
      PrintField("responses", responses_, writer);
    }
    #endregion
    
    public static OnVisualSearchResultProtocol ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OnVisualSearchResultProtocol ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OnVisualSearchResultProtocol MakeReadOnly() {
      responses_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OnVisualSearchResultProtocol prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<OnVisualSearchResultProtocol, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OnVisualSearchResultProtocol cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OnVisualSearchResultProtocol result;
      
      private OnVisualSearchResultProtocol PrepareBuilder() {
        if (resultIsReadOnly) {
          OnVisualSearchResultProtocol original = result;
          result = new OnVisualSearchResultProtocol();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OnVisualSearchResultProtocol MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override OnVisualSearchResultProtocol DefaultInstanceForType {
        get { return global::metaio.unitycommunication.OnVisualSearchResultProtocol.DefaultInstance; }
      }
      
      public override OnVisualSearchResultProtocol BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is OnVisualSearchResultProtocol) {
          return MergeFrom((OnVisualSearchResultProtocol) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OnVisualSearchResultProtocol other) {
        if (other == global::metaio.unitycommunication.OnVisualSearchResultProtocol.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasErrorCode) {
          ErrorCode = other.ErrorCode;
        }
        if (other.responses_.Count != 0) {
          result.responses_.Add(other.responses_);
        }
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_onVisualSearchResultProtocolFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _onVisualSearchResultProtocolFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasErrorCode = input.ReadInt32(ref result.errorCode_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.responses_, global::metaio.unitycommunication.VisualSearchResponse.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasErrorCode {
        get { return result.hasErrorCode; }
      }
      public int ErrorCode {
        get { return result.ErrorCode; }
        set { SetErrorCode(value); }
      }
      public Builder SetErrorCode(int value) {
        PrepareBuilder();
        result.hasErrorCode = true;
        result.errorCode_ = value;
        return this;
      }
      public Builder ClearErrorCode() {
        PrepareBuilder();
        result.hasErrorCode = false;
        result.errorCode_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::metaio.unitycommunication.VisualSearchResponse> ResponsesList {
        get { return PrepareBuilder().responses_; }
      }
      public int ResponsesCount {
        get { return result.ResponsesCount; }
      }
      public global::metaio.unitycommunication.VisualSearchResponse GetResponses(int index) {
        return result.GetResponses(index);
      }
      public Builder SetResponses(int index, global::metaio.unitycommunication.VisualSearchResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.responses_[index] = value;
        return this;
      }
      public Builder SetResponses(int index, global::metaio.unitycommunication.VisualSearchResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.responses_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddResponses(global::metaio.unitycommunication.VisualSearchResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.responses_.Add(value);
        return this;
      }
      public Builder AddResponses(global::metaio.unitycommunication.VisualSearchResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.responses_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeResponses(scg::IEnumerable<global::metaio.unitycommunication.VisualSearchResponse> values) {
        PrepareBuilder();
        result.responses_.Add(values);
        return this;
      }
      public Builder ClearResponses() {
        PrepareBuilder();
        result.responses_.Clear();
        return this;
      }
    }
    static OnVisualSearchResultProtocol() {
      object.ReferenceEquals(global::metaio.unitycommunication.UnityCommunicationProtos.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
